"use strict";
/**
 * Load features.
 *
 * See: https://github.com/cucumber/cucumber-js/blob/main/src/api/load_sources.ts
 * See: https://github.com/cucumber/cucumber-js/blob/main/src/api/gherkin.ts
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeaturesLoader = void 0;
exports.resolveFeatureFiles = resolveFeatureFiles;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const gherkin_1 = require("@cucumber/gherkin");
const gherkin_utils_1 = require("@cucumber/gherkin-utils");
const messages_1 = require("@cucumber/messages");
const paths_1 = require("../utils/paths");
const utils_1 = require("../utils");
function resolveFeatureFiles(cwd, patterns) {
    return (0, paths_1.resolveFiles)(cwd, (0, utils_1.toArray)(patterns), 'feature');
}
const newId = messages_1.IdGenerator.uuid();
class FeaturesLoader {
    constructor() {
        this.gherkinQuery = new gherkin_utils_1.Query();
        this.parseErrors = [];
    }
    async load(absFeatureFiles, options) {
        this.gherkinQuery = new gherkin_utils_1.Query();
        this.parseErrors = [];
        // Load features sequentially (as it was in gherkin-streams).
        // Potentially it can be parallelized in the future.
        // See: https://github.com/cucumber/gherkin-streams/blob/main/src/GherkinStreams.ts#L30
        for (const featureFile of absFeatureFiles) {
            await this.loadFeature(featureFile, options);
        }
    }
    getDocumentsCount() {
        return this.gherkinQuery.getGherkinDocuments().length;
    }
    getDocumentsWithPickles() {
        return this.gherkinQuery.getGherkinDocuments().map((gherkinDocument) => {
            const pickles = this.getDocumentPickles(gherkinDocument);
            return { ...gherkinDocument, pickles };
        });
    }
    async loadFeature(featureFile, options) {
        const uri = getFeatureUri(featureFile, options);
        const gherkinSource = await node_fs_1.default.promises.readFile(featureFile, 'utf8');
        const gherkinOptions = makeGherkinOptions(options);
        const envelopes = (0, gherkin_1.generateMessages)(gherkinSource, uri, messages_1.SourceMediaType.TEXT_X_CUCUMBER_GHERKIN_PLAIN, gherkinOptions);
        envelopes.forEach((envelope) => {
            this.gherkinQuery.update(envelope);
            if (envelope.parseError) {
                this.parseErrors.push(envelope.parseError);
            }
        });
    }
    getDocumentPickles(gherkinDocument) {
        return this.gherkinQuery
            .getPickles()
            .filter((pickle) => gherkinDocument.uri === pickle.uri)
            .map((pickle) => this.getPickleWithLocation(pickle));
    }
    getPickleWithLocation(pickle) {
        const lastAstNodeId = pickle.astNodeIds[pickle.astNodeIds.length - 1];
        const location = this.gherkinQuery.getLocation(lastAstNodeId);
        return { ...pickle, location };
    }
}
exports.FeaturesLoader = FeaturesLoader;
function makeGherkinOptions(options) {
    return {
        defaultDialect: options.defaultDialect,
        includeSource: true,
        includeGherkinDocument: true,
        includePickles: true,
        newId,
    };
}
function getFeatureUri(featureFile, options) {
    return options.relativeTo ? node_path_1.default.relative(options.relativeTo, featureFile) : featureFile;
}
//# sourceMappingURL=featuresLoader.js.map